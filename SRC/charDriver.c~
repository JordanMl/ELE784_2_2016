///Includes d'origine
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/types.h>
#include <linux/slab.h>
#include <linux/errno.h>
#include <linux/fcntl.h>
#include <linux/wait.h>
#include <linux/spinlock.h>
#include <linux/device.h>
#include <asm/atomic.h>
#include <asm/uaccess.h>

///Nouveaux includes :
#include <linux/rwsem.h>  ///semaphore lecteur/ecrivain
#include <linux/sched.h> // Required for task states (TASK_INTERRUPTIBLE etc )
#include <linux/ioctl.h> // Used for ioctl command


MODULE_LICENSE("Dual BSD/GPL");

//----Function prototypes-----
int ele784_open (struct inode *inode, struct file *filp);
int ele784_release (struct inode *inode, struct file *filp);
static ssize_t ele784_read (struct file *filp, char __user *ubuf, size_t count,
                  loff_t *f_ops);
static int ele784_ioctl (struct file *filp, unsigned int cmd, unsigned long arg);

//Structure à peupler, fonctions accessibles par l'utilisateur
struct file_operations Buf_fops =
{
    .owner = THIS_MODULE,
    .open = ele784_open,
    .release = ele784_release,
    .read = ele784_read,
    .unlocked_ioctl = ele784_ioctl,
};


//----Functions-----

/*

//Initialisation du pilote
int ele784_init(void) {

    //Allocation dynamique de l'unité-matériel
    result = MKDEV(250, 0); //MAJOR = 250  MINOR = 0
    if (result< 0)
        printk(KERN_WARNING"buf_init ERROR IN alloc_chrdev_region (%s:%s:%u)\n", __FILE__, __FUNCTION__, __LINE__);
    else
        printk(KERN_WARNING"buf_init : MAJOR = %u MINOR = %u \n", MAJOR(BDev.dev), MINOR(BDev.dev));
	 
    //Création de notre noeud d'unité-matériel
    BDev.BufferDev_class =  class_create(THIS_MODULE, "NAME");
    device_create(BDev.BufferDev_class, NULL, BDev.dev, NULL, "NAME_node");
    cdev_init(&BDev.cdev, &Buf_fops);
    BDev.cdev.owner = THIS_MODULE;
    if(cdev_add(&BDev.cdev, BDev.dev, 1) < 0)
        printk(KERN_WARNING"BDev ERROR IN cdev_add (%s:%s:%u)\n", __FILE__, __FUNCTION__, __LINE__);

    return 0;
}

///Fermeture du pilote
void ele784__exit(void) {
    

    cdev_del(&BDev.cdev);   //remove cdev from the system
    unregister_chrdev_region(BDev.dev, 1);   //free major number allocation
    device_destroy(BDev.BufferDev_class, BDev.dev);
    class_destroy(BDev.BufferDev_class);

    printk(KERN_ALERT"Buffer_exit (%s:%u) => CharPilote is dead !!\n", __FUNCTION__, __LINE__);
}

*/

//Accès au pilote par l'usager
int ele784_open (struct inode *inode, struct file *filp){

   
	 return 0;
}

//Libération du pilote par l'usager
int ele784_release (struct inode *inode, struct file *filp) {

	 printk(KERN_WARNING"buf_release (%s:%u)\n", __FUNCTION__, __LINE__);
	 return 0;
}

ssize_t ele784__read (struct file *filp, char __user *ubuf, size_t count,
                  loff_t *f_ops){


    return 0;
}


int ele784_ioctl (struct file *filp, unsigned int cmd, unsigned long arg){


    switch(cmd){
        case IOCTL_GET :  
             break;
        case IOCTL_SET :
				 break;
        case IOCTL_STREAMON : 
             break;
        case IOCTL_STREAMOFF : 
			    break;
		  case IOCTL_GRAB : 
			    break;
		  case IOCTL_PANTILT : 
			    break;
		  case IOCTL_PANTILT_RESEST : 
			    break;

        default : return -ENOTTY;
    }

    printk(KERN_WARNING"ele784_ioctl (%s:%u)\n   END /n ", __FUNCTION__, __LINE__);
	return retval;
}

module_usb_driver(skel_driver);
